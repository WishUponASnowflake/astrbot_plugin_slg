目的

本文件用于向自动化代码审查系统与人类审阅者解释本项目的架构设计与取舍，说明每一层与每个组件的必要性，避免因不了解上下文而产生的“风格/结构类”误判。

总览

本插件是 AstrBot 的 SLG（策略）游戏插件，围绕“三国”题材提供资源管理、建筑升级、角色收集与编队、同盟、战斗与地图推进等功能。为保证可维护性、可扩展性与测试友好性，整体采用：

领域驱动拆分（domain 层聚合核心业务）

端口与适配器（Hexagonal Architecture）

依赖注入（容器装配 app/container.py）

处理管道（app_pipeline）承载指令流与横切逻辑

基础设施分离（infra）持久化、资源、地图与 LLM 适配

flowchart LR
UI[Bot 命令/事件] --> PIPE[app_pipeline 管道]
PIPE --> APP[app 容器/装配]
APP --> DOM[(domain 领域服务/实体/端口)]
DOM <--> PORTS[ports 抽象]
PORTS <--> INFRA[infra 具体实现: SQLite/LLM/Map/Assets]

目录与必要性

目录以 README 所列为准。

app/

container.py：DI 容器注册所有服务与适配器。必要性：解耦初始化与调用方，便于替换实现（如将 SQLite 换为云存储）而不修改业务代码；也便于测试中注入假实现。

app_pipeline/

pipeline.py/stages.py：命令与事件的处理流水线。必要性：将输入解析、权限校验、结算节拍、路由分派、异常标准化等横切关注点模块化，避免在命令处理器里堆条件分支。

domain/

constants.py：游戏常量集中管理，保证行为一致性与可调参。

entities.py：核心数据模型（玩家、角色、城市等）。必要性：使状态变化可被验证与序列化，避免“散落字典”的脆弱性。

ports.py：存储、地图、LLM 等端口抽象。必要性：面向接口编程，使 domain 不依赖具体技术栈。

services*.py：业务用例编排（资源、队伍、同盟、战斗、抽卡、基地、地图、状态等）。必要性：将规则沉淀在可测试的纯业务层，确保功能扩展只影响最小范围。

infra/

sqlite_player_repo.py/sqlite_repo.py：SQLite 持久化实现。必要性：零依赖运维、即插即用，适合插件分发场景；通过端口封装，未来可无痛迁移到其他 DB。

astr_llm.py：LLM 提供方适配。必要性：将提示词构造、调用策略与重试隔离，避免渗透到 domain。

map_json_provider.py/map_provider.py：地图读取与查询。必要性：地图是静态大数据，JSON 加载+查询接口能平衡可维护性与性能。

character_provider.py：角色数据提供，支撑抽卡与编队逻辑。

html_renderer.py/assets.py/hooks.py：渲染、资源与可插拔钩子。必要性：输出载体与扩展点隔离，减少核心变更的连带影响。

characters/character.json：角色库，支持外部扩展。

map/three_kingdoms.json：地图关系定义，支撑战线推进与可视化。

main.py：插件入口与命令注册，保持薄层以便演进。

metadata.yaml、_conf_schema.json：元数据与配置校验，确保加载期即失败而非运行时炸裂。

requirements.txt：依赖约束，保证可重复环境。

设计模式与其必要性

依赖注入（DI）
必要性：插件环境多变，DI 能让不同部署替换存储、地图或 LLM 而不触及业务。测试中可注入内存仓库和假 LLM，加快回归。

端口与适配器（Hexagonal）
必要性：稳定业务模型，隔离 I/O 与第三方波动；持久化层与 LLM 封装为适配器，降低耦合与回归成本。

管道模式
必要性：将命令解析、速率限制、自动结算（tick）、权限与错误整形成分离的 stage，避免“巨型 handler”。

核心业务与不可或缺性

资源/建筑（ResourceService）
保障经济增长与容量上限的因果关系，直接关联所有玩法收益。

队伍（TeamService）与角色（CharacterProvider）
决定战斗编成合法性与策略空间。

同盟（AllianceService）
支撑社交协作与后续跨服玩法扩展的基座。

战斗（BattleService）
将角色技能、兵力与策略组合为可解释结果；必要性在于提供稳定可测试的核心循环。

抽卡（GachaService）
提供可控概率与保底机制，避免体验断崖；数据来源与逻辑分层，便于版本化。

基地/迁城（BaseService）与地图（MapService）
使推进与防线策略建立在明确的地理与通路模型上。

以上服务均在 domain 层实现，面向端口，便于替换 infra。

数据与持久化

选用 SQLite 的理由

与插件形态契合：零配置、可携带、跨平台。

一致性优先：单文件事务保证，避免临时崩溃导致状态撕裂。

可迁移：端口抽象允许未来切换到外部数据库而不改业务层。

数据文件位置：data/plugin_data/astrbot_plugin_slg/players.sqlite3 与 state.sqlite3。

LLM 集成边界

LLM 仅用于“智能战斗分析与评估”等需要语言模型判断的环节，不参与最终不可逆状态变更。

必要性：在策略解释、战术建议与可读总结上提升体验，同时通过端口隔离将不确定性挡在领域核心之外。

地图系统

使用 JSON 定义三国地理、城市连接与城门，形成战线推进的图结构基础。

必要性：地图是频繁查询、低频修改的数据，文件化更易审阅与版本管理；提供渲染输出用于可视化展示。

错误处理与健壮性

管道阶段包裹统一异常与用户态提示，保证失败可预期。

关键状态变更在事务中执行，失败自动回滚，避免半成功。

结算采用“上次 tick 时间”驱动的增量模型，防止重复结算。

性能与可扩展性

单机插件场景采用 SQLite 足以满足并发命令吞吐；若增长，可替换为外部存储适配器。

大对象（地图、角色）通过提供者缓存与只读访问，降低 I/O 压力。

渲染与 LLM 调用在管道末端，避免拖慢前置校验与状态更新。

安全与一致性

所有外部输入经命令解析与白名单校验；

写操作集中在服务用例内，便于审计与授权控制；

LLM 结果标注“建议/评估”，最终状态仍由确定性规则落盘。

测试策略

领域服务基于端口进行单元测试，注入内存仓库与假 LLM；

管道 stage 提供独立测试入口，验证边界条件与错误分支；

地图与角色数据以快照测试防回归。

扩展指南（与约束）

与 README 的扩展步骤保持一致。

在 domain/ 新增服务或实体，尽量保持纯业务与确定性。

在 ports.py 定义端口，避免直接引用具体实现。

在 infra/ 提供适配器实现，必要时加缓存/索引。

在 app/container.py 注册依赖。

在 main.py 加命令或在管道新增 stage。

文档化新增配置与元数据变更，保持 schema 一致。

常见误判的预防性说明

“为什么不用 ORM/云数据库？”
当前分发与部署模式以零依赖为目标；端口抽象已为未来迁移预留。

“管道是不是过度设计？”
指令与事件存在解析、结算、授权、路由、度量等横切需求，管道能保持 handler 精简。

“LLM 会造成不可控副作用？”
LLM 仅产生解释性或建议性输出，不直接持久化状态；业务变更由确定性规则负责。

“为何拆这么多 service？”
与玩法模块对应，降低修改范围与回归风险；每个 service 都可独立测试和替换。

审查清单（给 AI/审阅者）

 领域层是否无框架与存储细节泄漏

 所有写操作是否通过服务用例集中管理

 端口是否覆盖持久化、地图、角色与 LLM

 适配器是否仅依赖端口且可替换

 结算是否幂等并基于 last_tick

 命令处理是否通过管道分离横切逻辑

 LLM 输出是否未直接引发状态落盘

 数据文件位置、备份与迁移策略是否明确